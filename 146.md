# LRUCache

## Описание

Кэш (cache) — это компонент, который хранит данные, чтобы ускорить будущие запросы к этим данным. Когда запрашиваются данные, кэш сначала проверяет, есть ли эти данные в нем (попадание в кэш). Если да, данные возвращаются немедленно. Если данных нет в кэше (промах в кэше), они извлекаются из исходного источника, сохраняются в кэше для будущего использования и затем возвращаются.

Кэш LRU (Least Recently Used, наименее недавно использованный) — это тип кэша, где наименее недавно использованные элементы удаляются первыми, когда кэш достигает своей емкости. Это обеспечивает сохранение часто запрашиваемых элементов в кэше, что повышает производительность.

## Структура данных LRU Cache

Кэш LRU должен поддерживать следующие операции:
- **`get(int key)`**: Возвращает значение ключа, если ключ существует в кэше, в противном случае возвращает `-1`.
- **`put(int key, int value)`**: Обновляет или вставляет значение ключа. Если количество ключей превышает емкость кэша после этой операции, удаляется наименее недавно использованный ключ.

## Детали реализации

Для достижения средней временной сложности O(1) для операций `get` и `put`, мы можем использовать комбинацию:
1. **Хэш-таблица**: Для хранения пар ключ-значение и обеспечения доступа за O(1).
2. **Двусвязный список**: Для поддержания порядка ключей по их использованию. Наиболее недавно использованные элементы находятся в конце, а наименее недавно использованные — в начале.

Вот полная реализация на Kotlin:

```kotlin
class LRUCache(private val capacity: Int) {

    // Класс узла для двусвязного списка
    private data class Node(val key: Int, var value: Int, var prev: Node? = null, var next: Node? = null)

    // Фиктивные головной и хвостовой узлы для упрощения условий границ
    private val head = Node(-1, -1)
    private val tail = Node(-1, -1)

    // Карта для хранения соответствий ключ-узел
    private val map = mutableMapOf<Int, Node>()

    init {
        head.next = tail
        tail.prev = head
    }

    // Получение значения из кэша
    fun get(key: Int): Int {
        val node = map[key] ?: return -1
        remove(node)
        insertAtEnd(node)
        return node.value
    }

    // Вставка значения в кэш
    fun put(key: Int, value: Int) {
        if (key in map) {
            remove(map[key]!!)
        } else if (map.size == capacity) {
            remove(head.next!!)
        }

        val newNode = Node(key, value)
        insertAtEnd(newNode)
        map[key] = newNode
    }

    // Удаление узла из списка и карты
    private fun remove(node: Node) {
        node.prev!!.next = node.next
        node.next!!.prev = node.prev
        map.remove(node.key)
    }

    // Вставка узла в конец списка
    private fun insertAtEnd(node: Node) {
        node.prev = tail.prev
        node.next = tail
        tail.prev!!.next = node
        tail.prev = node
    }
}


 

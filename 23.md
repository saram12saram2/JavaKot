using a min-heap (or priority queue) is a more efficient approach for merging k sorted linked lists. 
This method leverages the properties of the min-heap to always pull the smallest current node from the k lists, ensuring that the merge process remains efficient.



![image](https://github.com/saram12saram2/JavaKot/assets/133630488/cd1a2776-8425-4ba5-a142-6235fb44031a)


    k is calculated as the size of the input lists plus one. This value is used to initialize the min-heap.
    A min-heap (priority queue) is initialized to store nodes based on their values. The compareBy function ensures that the nodes are ordered by their values.


   * k вычисляется как размер входного массива lists плюс один. Это значение используется для инициализации мин-кучи.
   * Мин-куча (priority queue) инициализируется для хранения узлов на основе их значений. Функция compareBy обеспечивает упорядочение узлов по их значениям.

#### Add Initial Nodes to Min-Heap


![image](https://github.com/saram12saram2/JavaKot/assets/133630488/d996e04a-9076-409c-a206-badb206a3416)



![image](https://github.com/saram12saram2/JavaKot/assets/133630488/24f7930e-4567-4680-9588-efafcba202bb)


![image](https://github.com/saram12saram2/JavaKot/assets/133630488/99a9ee77-bb66-4fed-8ba6-9938d2ea2f8d)



**Основная функция mergeKLists** 

```
fun mergeKLists(lists: Array<ListNode?>): ListNode? {
```

Эта функция принимает массив отсортированных связанных списков lists и возвращает один объединенный отсортированный связанный список.
Инициализация мин-кучи


```
   val k = lists.size + 1
   val minHeap = PriorityQueue<ListNode>(k, compareBy( { it.`val` } ))
```

   * k — это размер массива lists плюс один. Это значение используется для инициализации мин-кучи.
   * minHeap — это мин-куча (priority queue), которая будет хранить узлы связанных списков, упорядоченные по значению узла.
     Функция compareBy обеспечивает упорядочение узлов по их значениям.

**Добавление начальных узлов в мин-кучу** 

```
lists.forEach { headNode ->
 if (headNode != null) minHeap.offer(headNode)
  }
```

   * Итерация по каждому списку в lists.
   * Если головной узел списка не равен null, добавляем его в мин-кучу.
     Это гарантирует, что наименьший узел из каждого списка первоначально присутствует в мин-куче.

**Процесс слияния** 

```
      var result: ListNode? = null
      var resultBuilder = result
```

   * result — это головной узел результирующего объединенного списка.
   * resultBuilder используется для построения результирующего списка.


```
        while (minHeap.size > 0) {
            val nextNode = minHeap.poll()
```

   * Пока мин-куча не пуста, извлекаем наименьший узел из мин-кучи и сохраняем его в nextNode.

```
            if (result == null) {
                result = nextNode
                resultBuilder = nextNode
            } else {
                resultBuilder!!.next = nextNode
                resultBuilder = nextNode
            }
```

   * Если result равен null, это означает, что мы добавляем первый узел в результирующий список. Инициализируем result и resultBuilder этим узлом.
   * В противном случае прикрепляем извлеченный узел к resultBuilder.next и перемещаем resultBuilder на следующий узел.

```
            if (nextNode.next != null) {
                minHeap.offer(nextNode.next)
            }
        }
```

   * Если у извлеченного узла есть следующий узел, добавляем следующий узел в мин-кучу.

**Возвращение результата** 

```
        return result
    }
}
```
   * Возвращаем головной узел объединенного списка.






Пример

Давайте рассмотрим пример слияния трёх списков:

Вход: lists = [[1,4,5], [1,3,4], [2,6]]

    Инициализация мин-кучи:
        Добавляем головные узлы из каждого списка в мин-кучу.
        Мин-куча: [1, 1, 2]

    + Первая итерация:
        Извлекаем наименьший узел (1) из мин-кучи.
        Добавляем следующий узел (4) из первого списка в мин-кучу.
        Результат: 1
        Мин-куча: [1, 2, 4]

    + Вторая итерация:
        Извлекаем наименьший узел (1) из мин-кучи.
        Добавляем следующий узел (3) из второго списка в мин-кучу.
        Результат: 1 -> 1
        Мин-куча: [2, 4, 3]

    + Третья итерация:
        Извлекаем наименьший узел (2) из мин-кучи.
        Добавляем следующий узел (6) из третьего списка в мин-кучу.
        Результат: 1 -> 1 -> 2
        Мин-куча: [3, 4, 6]

    + Последующие итерации:
        Продолжаем этот процесс, извлекая наименьший узел и добавляя его следующий узел в мин-кучу, пока куча не опустеет.
        Конечный результат: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6

Таким образом, этот подход использует мин-кучу для эффективного слияния k отсортированных списков в один отсортированный список, 
обеспечивая минимальное количество сравнений и упорядоченное добавление узлов.




![image](https://github.com/saram12saram2/JavaKot/assets/133630488/1578f4a8-a18b-4cc2-9dfb-42a2f74591ae)
